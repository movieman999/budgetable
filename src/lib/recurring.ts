import { Transaction, RecurringTemplate, RecurringSchedule } from "./types";
import { addDays, addWeeks, addMonths, setDate, isAfter, isBefore, startOfMonth, endOfMonth, isSameDay } from "date-fns";

/**
 * Generate forecasted transactions from recurring templates for a given month.
 * Only generates for FUTURE dates - past dates should already have real transactions.
 */
export function generateForecastedTransactions(
  templates: RecurringTemplate[],
  targetMonth: Date,
  existingTransactions: Transaction[]
): Transaction[] {
  const forecasted: Transaction[] = [];
  const monthStart = startOfMonth(targetMonth);
  const monthEnd = endOfMonth(targetMonth);
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  // Build a set of existing transaction keys to avoid duplicates
  const existingKeys = new Set(
    existingTransactions
      .filter((t) => t.recurringTemplateId)
      .map((t) => `${t.recurringTemplateId}-${new Date(t.date).toDateString()}`)
  );

  templates.forEach((template) => {
    if (!template.isActive) return;

    const schedule = template.schedule;
    const startDate = new Date(schedule.startDate);

    // Generate occurrences for this month
    const occurrences = getOccurrencesInMonth(startDate, schedule, monthStart, monthEnd);

    occurrences.forEach((date) => {
      const dateKey = `${template.id}-${date.toDateString()}`;
      
      // Skip if a real transaction already exists for this occurrence
      if (existingKeys.has(dateKey)) return;
      
      // Only forecast future dates
      if (isAfter(date, today)) {
        forecasted.push({
          id: `forecast-${template.id}-${date.getTime()}`,
          type: template.type,
          amount: template.amount,
          category: template.category,
          description: template.description,
          date,
          verified: false,
          accountId: template.accountId,
          isForecasted: true,
          recurringTemplateId: template.id,
          wasAutoGenerated: true,
        });
      }
    });
  });

  return forecasted;
}

/**
 * Create a real transaction from a recurring template when its date arrives.
 * This should be called when viewing a month to "materialize" past occurrences.
 */
export function materializePastOccurrences(
  templates: RecurringTemplate[],
  targetMonth: Date,
  existingTransactions: Transaction[]
): Transaction[] {
  const newTransactions: Transaction[] = [];
  const monthStart = startOfMonth(targetMonth);
  const monthEnd = endOfMonth(targetMonth);
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  // Build a set of existing transaction keys
  const existingKeys = new Set(
    existingTransactions
      .filter((t) => t.recurringTemplateId)
      .map((t) => `${t.recurringTemplateId}-${new Date(t.date).toDateString()}`)
  );

  templates.forEach((template) => {
    if (!template.isActive) return;

    const schedule = template.schedule;
    const startDate = new Date(schedule.startDate);

    // Generate occurrences for this month
    const occurrences = getOccurrencesInMonth(startDate, schedule, monthStart, monthEnd);

    occurrences.forEach((date) => {
      const dateKey = `${template.id}-${date.toDateString()}`;
      
      // Skip if already exists
      if (existingKeys.has(dateKey)) return;
      
      // Only materialize past/today dates (not future)
      if (!isAfter(date, today)) {
        newTransactions.push({
          id: crypto.randomUUID(),
          type: template.type,
          amount: template.amount,
          category: template.category,
          description: template.description,
          date,
          verified: false,
          accountId: template.accountId,
          isForecasted: false,
          recurringTemplateId: template.id,
          wasAutoGenerated: true,
        });
        // Add to existing keys to prevent duplicates within same call
        existingKeys.add(dateKey);
      }
    });
  });

  return newTransactions;
}

function getOccurrencesInMonth(
  startDate: Date,
  schedule: RecurringSchedule,
  monthStart: Date,
  monthEnd: Date
): Date[] {
  const occurrences: Date[] = [];
  let currentDate = new Date(startDate);

  // If the start date is after the month end, no occurrences
  if (isAfter(currentDate, monthEnd)) return [];

  // Move to the first occurrence in or after the month start
  while (isBefore(currentDate, monthStart)) {
    currentDate = getNextOccurrence(currentDate, schedule);
  }

  // Collect all occurrences within the month
  while (!isAfter(currentDate, monthEnd)) {
    occurrences.push(new Date(currentDate));
    currentDate = getNextOccurrence(currentDate, schedule);
  }

  return occurrences;
}

function getNextOccurrence(currentDate: Date, schedule: RecurringSchedule): Date {
  switch (schedule.type) {
    case 'weekly':
      return addWeeks(currentDate, 1);
    case 'biweekly':
      return addWeeks(currentDate, 2);
    case 'monthly':
      // If a specific day of month is set, use that
      if (schedule.dayOfMonth) {
        let nextMonth = addMonths(currentDate, 1);
        // Handle months with fewer days
        const maxDay = new Date(nextMonth.getFullYear(), nextMonth.getMonth() + 1, 0).getDate();
        const targetDay = Math.min(schedule.dayOfMonth, maxDay);
        return setDate(nextMonth, targetDay);
      }
      return addMonths(currentDate, 1);
    case 'custom':
      return addDays(currentDate, schedule.customDays || 30);
    default:
      return addMonths(currentDate, 1);
  }
}

/**
 * Combine actual transactions with forecasted ones for display
 */
export function mergeTransactionsWithForecasted(
  existingTransactions: Transaction[],
  forecastedTransactions: Transaction[]
): Transaction[] {
  // Forecasted transactions already exclude those with existing real transactions
  // So we can simply combine them
  return [...existingTransactions, ...forecastedTransactions];
}
